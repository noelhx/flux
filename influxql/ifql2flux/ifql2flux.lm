namespace flux
	include 'flux.lm'
end

include 'influxql.lm'

parse P: influxql [stdin] 
if ( !P ) {
	send stderr "error parsing influxql query: [error]
	exit( 1 )
}

#
# Part of the first stab at yanking time from the where clause. Not used. Turns
# out a different approach is required. 
#
void normalize_conjunctions( Expr: ref<expr> )
{
	Modified: bool = true
	while ( Modified ) {
		Modified = false
		for SLE: conjunction_expression in Expr {
			if match SLE
				[ `( CE: conjunction_expression `) ] 
			{
				SLE = CE
				Modified = true
			}
			else if match SLE
				[ LeftCE: conjunction_expression `AND `( InnerCE: conjunction_expression `) ] 
			{
				# Place LeftCE at the end of the InnerCE list.
				for Tail: conjunction_expression in InnerCE {
					if match Tail [Last: comparison_expression] {
						Tail = cons conjunction_expression " [LeftCE] AND [Last] "
						# Must break here to end the replacement loop.
						break
					}
				}

				SLE = InnerCE
				Modified = true
			}
		}
	}
}

bool time_constraint( Any: any )
{
	for UE: unary_expr in Any {
		if match UE "time"
			return true
	}
	return false
}

# Reports an error if any disjunctions of time are found. The official influxql
# parser allows them, just yanks them from the expression and AND's them
# together, so we don't use this function, just here for reference.
void disjunctions_of_time( Expr: expr )
{
	Error: bool = false
	for DE: disjunction_expression in Expr {
		if match DE
			[Left: disjunction_expression `OR Right: conjunction_expression]
		{
			if time_constraint( Left ) || time_constraint( Right ) {
				print "ERROR: disjunction of time found: [^DE]
				Error = true
			}
		}
	}
	if ( Error )
		exit( 1 )
}

def time_range
	Start: comparison_expression
	Stop: comparison_expression
[]

bool check_time( Range: ref<time_range>, CE: comparison_expression )
{
	if match CE "time [Op: comparison_operator Rhs: additive_expression ] "
			&& ( match Op "<" || match Op "<=" )
	{
		Range.Stop = cons comparison_expression [Rhs]
		return true
	}

	if match CE "time [Op: comparison_operator Rhs: additive_expression ] "
			&& ( match Op ">" || match Op ">=" )
	{
		Range.Start = cons comparison_expression [Rhs]
		return true
	}
	
	return false
}

# Find time constraints and verify we can handle them.
void yank_time( Range: ref<time_range>, Expr: ref<expr> )
{
	Error: bool = false
	for CE: comparison_expression in Expr {
		if ( time_constraint( CE ) ) {
			if !match CE "( [expr] )"
			{
				if !check_time( Range, CE ) {
					send stderr "ERROR: wonky time constraint: [CE]
					Error = true
				}

				CE = cons comparison_expression " __ERASE_ME__ "
			}
		}
	}

	if ( Error )
		exit(1)
}

# Remove the expression components left behind by the time yanking.
void clean_expr( Expr: ref<expr> )
{
	Modified: bool = true
	while ( Modified ) {
		Modified = false
		for DE: disjunction_expression in Expr {
			if match DE
				"[ Left: disjunction_expression ] OR __ERASE_ME__"
			{
				DE = Left
				Modified = true
			}
			else if match DE
				"__ERASE_ME__ OR [ Right: conjunction_expression ]"
			{
				DE = cons disjunction_expression [Right]
				Modified = true
			}
		}

		for CE: conjunction_expression in Expr {
			if match CE
				"[ Left: conjunction_expression ] AND __ERASE_ME__"
			{
				CE = Left
				Modified = true
			}
			else if match CE
				"__ERASE_ME__ AND [ Right: comparison_expression ]"
			{
				CE = cons conjunction_expression [Right]
				Modified = true
			}
		}

		for CmpE: comparison_expression in Expr {
			if match CmpE "( __ERASE_ME__ )" {
				CmpE = cons comparison_expression "__ERASE_ME__"
				Modified = true
			}
		}
	}
}

# 1. Extract time constraints from the where clause.
# 2. Build range from extracted time constraints.
# 3. Build filter from remaining where clause (not implemented).
# 4. Apply Group By (not implemented)
# 5. Apply Select Expressions (not implemented).

alias output parser<flux::flux>

for SS: select_stmt in P {
	new Output: output()

	# send stderr "select statement: [^SS]
	cons Range: time_range []

	WC: where_clause = SS.opt_where_clause.where_clause
	if WC {
		Expr: expr = WC.expr

		yank_time( Range, Expr )
		clean_expr( Expr )

		# send stderr "scrubbed where: [^Expr]
	}

	if !Range.Start
		Range.Start = cons comparison_expression "-1m"

	if argv->length < 1 {
		send stderr "usage: ./ifql2flux bucket-name
		exit(1)
	}

	# Bucket
	send Output
		"from( bucket: \"[argv->head_el->value]\")
	
	# Range
	send Output
		"	|> range( start: [Range.Start] "
	if Range.Stop
		send Output ", stop: [Range.Stop] "
	send Output " )

	send Output [] eos

	Flux: flux::flux = Output->tree
	if !Flux {
		send stderr "error parsing transformation output: [Output->error]
		exit(1)
	}
	else {
		print [Flux]
	}
}
