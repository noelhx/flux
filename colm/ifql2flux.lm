namespace flux
	include 'flux.lm'
end

include 'influxql.lm'

parse P: influxql [stdin]

if ( !P ) {
	print "[error]
	exit( 1 )
}

void normalize_conjunctions( Expr: ref<expr> )
{
	Modified: bool = true
	while ( Modified ) {
		Modified = false
		for SLE: conjunction_expression in Expr {
			if match SLE
				[ `( CE: conjunction_expression `) ] 
			{
				SLE = CE
				Modified = true
			}
			else if match SLE
				[ LeftCE: conjunction_expression `AND `( InnerCE: conjunction_expression `) ] 
			{
				# Place LeftCE at the end of the InnerCE list.
				for Tail: conjunction_expression in InnerCE {
					if match Tail [Last: comparison_expression] {
						Tail = cons conjunction_expression " [LeftCE] AND [Last] "
						# Must break here to end the replacement loop.
						break
					}
				}

				SLE = InnerCE
				Modified = true
			}
		}
	}
}

bool time_constraint( Any: any )
{
	for UE: unary_expr in Any {
		if match UE "time"
			return true
	}
	return false
}

void disjunctions_of_time( Expr: expr )
{
	Error: bool = false
	for DE: disjunction_expression in Expr {
		if match DE
			[Left: disjunction_expression `OR Right: conjunction_expression]
		{
			if time_constraint( Left ) || time_constraint( Right ) {
				print "ERROR: disjunction of time found: [^DE]
				Error = true
			}
		}
	}
	if ( Error )
		exit( 1 )
}

# Find time constraints and verify we can handle them.
void yank_time( Expr: ref<expr> )
{
	Error: bool = false
	for CE: comparison_expression in Expr {
		if ( time_constraint( CE ) ) {
			if
				!match CE "time [comparison_operator duration_lit] " &&
				!match CE "[duration_lit comparison_operator] time"
			{
				print "ERROR: wonky time constraint: [CE]
				Error = true
			}

			CE = cons comparison_expression " true "
		}
	}
	if ( Error )
		exit(1)
}

# 1. Normalize conjunctions.
# 2. Extract time constraints. Fail if we find any inside a disjunction.

# 1. Pull and apply the time constraint. Replace with true. Expect conjunction
# 2. Remaining where clause items.
# 3. Apply Group By.
# 4. Select Expressions
#

alias output parser<flux::flux>
new Output: output()

for SS: select_stmt in P {
	print "select statement:\n[^SS]\n"

	WC: where_clause = SS.opt_where_clause.where_clause
	if WC {
		Expr: expr = WC.expr

		normalize_conjunctions( Expr )
		disjunctions_of_time( Expr )
		yank_time( Expr )

		# print "normalized where clause expression:\n[^Expr]\n"
	}
}

send Output 'from("the-bucket")' [] eos
Flux: flux::flux = Output->tree

print "flux output:\n[^Flux]\n"

